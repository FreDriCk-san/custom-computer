#pragma once



#pragma region Список флагов
// Переполнение при выполнении операции
#define CF 1

// Ошибка деления на 0
#define ZF 2

// Ошибка выхода за границы памяти
#define OF 3

// Игнорирование тактовых импульсов
#define IF 4

// Указана неверная команда
#define MF 5
#pragma endregion


#pragma region Список команд ЦП

#pragma region Операции ввода/вывода
// Ввод с терминала в указанную ячейку памяти с контролем переполнения
#define READ 10

// Вывод на терминал значение указанной ячейки памяти
#define WRITE 11
#pragma endregion


#pragma region Операции загрузки/выгрузки в аккумулятор
// Загрузка в аккумулятор значения из указанного адреса памяти
#define LOAD 20

// Выгружает значение из аккумулятора по указанному адресу памяти
#define STORE 21
#pragma endregion


#pragma region Арифметические операции
// Выполняет сложение слова в аккумуляторе и слова из указанной ячейки памяти (результат в аккумуляторе)
#define ADD 30

// Вычитает из слова в аккумуляторе слово из указанной ячейки памяти (результат в аккумуляторе)
#define SUB 31

// Выполняет деление слова в аккумуляторе на слово из указанной ячейки памяти (результат в аккумуляторе)
#define DIVIDE 32

// Вычисляет произведение слова в аккумуляторе на слово из указанной ячейки памяти (результат в аккумуляторе)
#define MUL 33
#pragma endregion


#pragma region Операции передачи управления
// Переход к указанному адресу памяти
#define JUMP 40

// Переход к указанному адресу памяти, если в аккумуляторе находится отрицательное число
#define JNEG 41

// Переход к указанному адресу памяти, если в аккумуляторе находится ноль
#define JZ 42

// Останов, выполняется при завершении работы программы
#define HALT 43
#pragma endregion


#pragma region Пользовательские функции
// Двоичная инверсия слова в аккумуляторе и занесение результата в указанную ячейку памяти
#define NOT 51

// Логическая операция И между содержимым аккумулятора и словом по указанному адресу (результат в аккумуляторе)
#define AND 52

// Логическая операция ИЛИ между содержимым аккумулятора и словом по указанному адресу (результат в аккумуляторе)
#define OR 53

// Логическая операция исключающее ИЛИ между содержимым аккумулятора и словом по указанному адресу (результат в аккумуляторе)
#define XOR 54

// Переход к указанному адресу памяти, если в аккумуляторе находится положительное число
#define JNS 55

// Переход к указанному адресу памяти, если при сложении произошло переполнение
#define JC 56

// Переход к указанному адресу памяти, если при сложении не произошло переполнение
#define JNC 57

// Переход к указанному адресу памяти, если результат предыдущей операции четный
#define JP 58

// Переход к указанному адресу памяти, если результат предыдущей операции нечетный
#define JNP 59

// Логический двоичный сдвиг содержимого указанной ячейки памяти влево (результат в аккумуляторе)
#define CHL 60

// Логический двоичный сдвиг содержимого указанной ячейки памяти вправо (результат в аккумуляторе)
#define SHR 61

// Циклический двоичный сдвиг содержимого указанной ячейки памяти влево (результат в аккумуляторе)
#define RCL 62

// Циклический двоичный сдвиг содержимого указанной ячейки памяти вправо (результат в аккумуляторе)
#define RCR 63

// Получение дополнительного кода содержимого указанной ячейки памяти (результат в аккумуляторе)
#define NEG 64

// Сложение содержимого указанной ячейки памяти с ячейкой памяти, адрес которой находится в аккумуляторе (результат в аккумуляторе)
#define ADDC 65

// Вычитание из содержимого указанной ячейки памяти содержимого ячейки памяти, адрес которой находится в аккумуляторе (результат в аккумуляторе)
#define SUBC 66

// Логический двоичный сдвиг содержимого указанного участка памяти влево на количество разрядов указанное в аккумуляторе (результат в аккумуляторе)
#define LOGLC 67

// Логический двоичный сдвиг содержимого указанного участка памяти вправо на количество разрядов указанное в аккумуляторе (результат в аккумуляторе)
#define LOGRC 68

// Циклический двоичный сдвиг содержимого указанного участка памяти влево на количество разрядов указанное в аккумуляторе (результат в аккумуляторе)
#define RCCL 69

// Циклический двоичный сдвиг содержимого указанного участка памяти вправо на количество разрядов указанное в аккумуляторе (результат в аккумуляторе)
#define RCCR 70

// Перемещение содержимого указанной ячейки памяти в ячейку, адрес которой указан в аккумуляторе
#define MOVA 71

// Перемещение содержимого ячейки памяти, адрес которой содержится в аккумуляторе в указанную ячейку памяти
#define MOVR 72

// Перемещение содержимого указанной ячейки памяти в ячейку памяти, адрес которой находится в ячейке памяти, на которую указывает значение аккумулятора
#define MOVCA 73

// Перемещение в указанный участок памяти содержимого участка памяти, адрес которого находится в участке памяти указанном в аккумуляторе
#define MOVCR 74

// Сложение содержимого указанной ячейки памяти с ячейкой памяти, адрес которой находится в ячейке памяти, указанной в аккумуляторе (результат в аккумуляторе)
#define EADDC 75

// Вычитание из содержимого указанной ячейки памяти содержимого ячейки памяти, адрес которой находится в ячейке памяти, указанной в аккумуляторе (результат в аккумуляторе)
#define ESUBC 76
#pragma endregion

#pragma endregion


int sc_memoryInit();

int sc_memorySet(int address, int value);

int sc_memoryEncode(int value, int* number);

int sc_memorySetAndEncode(int address, int value, int* number);

int sc_memoryGet(int address, int* value);

int sc_numberDecode(int value, int* number);

int sc_memoryGetAndDecode(int address, int* number);

int sc_memorySave(char* filename);

int sc_memoryLoad(char* filename);

int sc_regInit(void);

int sc_regSet(int reg, int value);

int sc_regGet(int reg, int* value);

int sc_commandSet(int command);

int sc_commandEncode(int command, int operand, int* value);

int sc_commandSetAndEncode(int address, int command, int operand, int* value);

int sc_commandGet(int address, int* value);

int sc_commandDecode(int value, int* command, int* operand);

int sc_commandGetAndDecode(int address, int* command, int* operand);

int sc_instructGet();

void sc_instructSet(int value);

int sc_accumGet();

void sc_accumSet(int value);

void sc_reset();

bool sc_isNumber(int address);

int sc_run();

int sc_runByStep();